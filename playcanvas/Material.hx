package playcanvas;

/**
	A material determines how a particular mesh instance is rendered. It specifies the shader and
	render state that is set before the mesh instance is submitted to the graphics device.
**/
@:jsRequire("playcanvas", "Material") extern class Material {
	function new();
	/**
		A shader used to render the material. Note that this is used only by materials where the
		user specifies the shader. Most material types generate multiple shader variants, and do not
		set this.
	**/
	private var _shader : Dynamic;
	/**
		The mesh instances referencing this material
	**/
	private var meshInstances : Dynamic;
	/**
		The name of the material.
	**/
	var name : String;
	var id : Float;
	var variants : { };
	var parameters : { };
	/**
		The alpha test reference value to control which fragments are written to the currently
		active render target based on alpha value. All fragments with an alpha value of less than
		the alphaTest reference value will be discarded. alphaTest defaults to 0 (all fragments
		pass).
	**/
	var alphaTest : Float;
	/**
		Enables or disables alpha to coverage (WebGL2 only). When enabled, and if hardware
		anti-aliasing is on, limited order-independent transparency can be achieved. Quality depends
		on the number of MSAA samples of the current render target. It can nicely soften edges of
		otherwise sharp alpha cutouts, but isn't recommended for large area semi-transparent
		surfaces. Note, that you don't need to enable blending to make alpha to coverage work. It
		will work without it, just like alphaTest.
	**/
	var alphaToCoverage : Bool;
	var _blendState : BlendState;
	var _depthState : DepthState;
	/**
		Controls how triangles are culled based on their face direction with respect to the
		viewpoint. Can be:
		
		- {@link CULLFACE_NONE}: Do not cull triangles based on face direction.
		- {@link CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing
		away from the view point).
		- {@link CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing
		towards the view point).
		
		Defaults to {@link CULLFACE_BACK}.
	**/
	var cull : Float;
	/**
		Stencil parameters for front faces (default is null).
	**/
	var stencilFront : Null<StencilParameters>;
	/**
		Stencil parameters for back faces (default is null).
	**/
	var stencilBack : Null<StencilParameters>;
	/**
		Offsets the output depth buffer value. Useful for decals to prevent z-fighting.
	**/
	var depthBias : Float;
	/**
		Same as {@link Material#depthBias}, but also depends on the slope of the triangle relative
		to the camera.
	**/
	var slopeDepthBias : Float;
	var _shaderVersion : Float;
	var _scene : Dynamic;
	var _dirtyBlend : Bool;
	var dirty : Bool;
	/**
		If true, the red component of fragments generated by the shader of this material is written
		to the color buffer of the currently active render target. If false, the red component will
		not be written. Defaults to true.
	**/
	var redWrite : Bool;
	/**
		If true, the green component of fragments generated by the shader of this material is
		written to the color buffer of the currently active render target. If false, the green
		component will not be written. Defaults to true.
	**/
	var greenWrite : Bool;
	/**
		If true, the blue component of fragments generated by the shader of this material is
		written to the color buffer of the currently active render target. If false, the blue
		component will not be written. Defaults to true.
	**/
	var blueWrite : Bool;
	/**
		If true, the alpha component of fragments generated by the shader of this material is
		written to the color buffer of the currently active render target. If false, the alpha
		component will not be written. Defaults to true.
	**/
	var alphaWrite : Bool;
	/**
		The shader used by this material to render mesh instances (default is null).
	**/
	var shader : Shader;
	final transparent : Bool;
	function _markBlendDirty():Void;
	/**
		Controls how fragment shader outputs are blended when being written to the currently active
		render target. This overwrites blending type set using {@link pc.Material#blendType}, and
		offers more control over blending.
	**/
	var blendState : BlendState;
	/**
		Controls how fragment shader outputs are blended when being written to the currently active
		render target. Can be:
		
		- {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
		fragment and write the result to the frame buffer.
		- {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment
		and write the result to the frame buffer.
		- {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
		equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
		blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
		- {@link BLEND_NONE}: Disable blending.
		- {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
		assumed to have already been multiplied by the source alpha value.
		- {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
		destination fragment and write the result to the frame buffer.
		- {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
		multiplied by the source alpha.
		- {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.
		- {@link BLEND_SCREEN}: Softer version of additive.
		- {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
		- {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
		
		Defaults to {@link BLEND_NONE}.
	**/
	var blendType : Float;
	/**
		Sets the depth state. Note that this can also be done by using {@link Material#depthTest},
		{@link Material#depthFunc} and {@link Material#depthWrite}.
	**/
	var depthState : DepthState;
	/**
		If true, fragments generated by the shader of this material are only written to the current
		render target if they pass the depth test. If false, fragments generated by the shader of
		this material are written to the current render target regardless of what is in the depth
		buffer. Defaults to true.
	**/
	var depthTest : Bool;
	/**
		Controls how the depth of new fragments is compared against the current depth contained in
		the depth buffer. Can be:
		
		- {@link FUNC_NEVER}: don't draw
		- {@link FUNC_LESS}: draw if new depth < depth buffer
		- {@link FUNC_EQUAL}: draw if new depth == depth buffer
		- {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
		- {@link FUNC_GREATER}: draw if new depth > depth buffer
		- {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
		- {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
		- {@link FUNC_ALWAYS}: always draw
		
		Defaults to {@link FUNC_LESSEQUAL}.
	**/
	var depthFunc : Float;
	/**
		If true, fragments generated by the shader of this material write a depth value to the depth
		buffer of the currently active render target. If false, no depth value is written. Defaults
		to true.
	**/
	var depthWrite : Bool;
	/**
		Copy a material.
	**/
	function copy(source:Material):Material;
	/**
		Clone a material.
	**/
	function clone():Material;
	function _updateMeshInstanceKeys():Void;
	function updateUniforms(device:Dynamic, scene:Dynamic):Void;
	function getShaderVariant(device:Dynamic, scene:Dynamic, objDefs:Dynamic, staticLightList:Dynamic, pass:Dynamic, sortedLights:Dynamic, viewUniformFormat:Dynamic, viewBindGroupFormat:Dynamic, vertexFormat:Dynamic):Shader;
	/**
		Applies any changes made to the material's properties.
	**/
	function update():Void;
	function clearParameters():Void;
	function getParameters():{ };
	function clearVariants():Void;
	/**
		Retrieves the specified shader parameter from a material.
	**/
	function getParameter(name:String):Dynamic;
	/**
		Sets a shader parameter on a material.
	**/
	function setParameter(name:String, data:ts.AnyOf4<Float, Array<Float>, Texture, js.lib.Float32Array>):Void;
	/**
		Deletes a shader parameter on a material.
	**/
	function deleteParameter(name:String):Void;
	function setParameters(device:Dynamic, names:Dynamic):Void;
	/**
		Removes this material from the scene and possibly frees up memory from its shaders (if there
		are no other materials using it).
	**/
	function destroy():Void;
	/**
		Registers mesh instance as referencing the material.
	**/
	function addMeshInstanceRef(meshInstance:MeshInstance):Void;
	/**
		De-registers mesh instance as referencing the material.
	**/
	function removeMeshInstanceRef(meshInstance:MeshInstance):Void;
	static var prototype : Material;
}